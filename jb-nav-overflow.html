<!--
    
    jb-nav-overflow
        A custom element that places "hidden" items in a menu

    Copyright 2016, Jesse Baird <jebaird@gmail.com> jebaird.com
    licensed under the MIT 


    Order of events 

        get the secondary handle width,
        get the first items height, set the height of the primary ul
        get the index of children that are not on the first line

        issue refreshed event ?
            
        call setOverflow on
            * window resize?
            * content changed
            * child appended 

    
-->

<style id="jb-nav-overflow-style">

    jb-nav-overflow {
        display: block;
    }

    /* why not use :unresolved ? it works in chrome but not firefox */
    jb-nav-overflow[unresolved]{
        opacity: 0;
    }

    jb-nav-overflow[refreshing],
    .jb-nav-overflow__secondary_nav__handle {
        visibility: hidden;

    }

</style>


<!-- 
    This template can be "overriden " by prodving the following a template tag with the class of jb "b-nav-overflow__secondary_nav__template"
    in the root of this element
    
    IE

    <jb-nav-overflow>

        <template class="jb-nav-overflow__secondary_nav__template">
            <nav class="jb-nav-overflow__secondary_nav this-is-an-override-test"><ul></ul></nav>
        </template> 
    <jb-nav-overflow>
-->
<template id="jb-nav-overflow-template">
    <nav class="jb-nav-overflow__secondary_nav"><ul></ul></nav>
</template>


<script>
(function() {

    // if the browser is using the webcompoents pollyfill we should look for document._currentScript
    var _currentScript = document._currentScript || document.currentScript;


    // Creates an object based in the HTML Element prototype
    var element = Object.create(HTMLElement.prototype);

    // Fires when an instance of the element is created
    element.createdCallback = function() {

        

        this._resizeObserver = new MutationObserver(function(){
            this.setOverflow();
        }.bind(this));


    };

    // Fires when an instance was inserted into the document
    element.attachedCallback = function() {
        
        this.setAttribute( 'unresolved', '' );

        // need to wait for the DOM to be completely parsed before we try to setup the overflow
        if ( document.readyState != "complete" ) {

            var readyCounter = setInterval(function(){

                if ( document.readyState == "complete" ) {
                    clearTimeout( readyCounter );

                    this.setOverflow();
                }

            }.bind( this ), 10 );


        } else {
            this.setOverflow();
        }



    };

    // Fires when an instance was removed from the document
    element.detachedCallback = function() {

        if ( this._resizeObserver ){

            this._resizeObserver.disconnect();
        }
    };

    // Fires when an attribute was added, removed, or updated
    element.attributeChangedCallback = function(attr, oldVal, newVal) {};



    element.setOverflow = function(){
        
        

        

        var secondaryMenuHandle = this.querySelector('.jb-nav-overflow__secondary_nav__handle'),
            primaryNav = secondaryMenuHandle.parentNode,
            oldSecondaryNav = this.querySelector('.jb-nav-overflow__secondary_nav');

        if ( secondaryMenuHandle === null || this.hasAttribute( 'refreshing' ) === true ) {
            // if we don't have a handle then we can't append the secondary nav to it
            return;
        }


        this.setAttribute('refreshing', '' );
        
        // default to our stylesheet
        secondaryMenuHandle.style.visibility = "";

        primaryNav.insertBefore( secondaryMenuHandle, primaryNav.firstChild );
        
        // since we observe the substree, disconnect so we don't recursively  call this method
        if ( this._resizeObserver ){

            this._resizeObserver.disconnect();
        }


        // do we have a secondary nav?
        if ( oldSecondaryNav ) {

            var secondaryItems = this._makeArray( oldSecondaryNav.querySelector('ul').children, 0 ),
                docFrag = document.createDocumentFragment(),
                item;

            
            while ( item = secondaryItems.shift () ) {
                docFrag.appendChild( item )
            }

            oldSecondaryNav.parentNode.removeChild( oldSecondaryNav );
            oldSecondaryNav = null;

            
            // get all of the items in the secondary and append them to the primary
            primaryNav.insertBefore( docFrag, primaryNav.lastChild );

        }


        

        var items = this._makeArray( primaryNav.children, 0 );

        var lastOfsetTop = null;

        items = items.filter( function( element ){ 

                    if ( lastOfsetTop == null ) {
                        lastOfsetTop = element.offsetTop
                    }
                    
                    
                    
                    return (
                            element.classList.contains( 'jb-nav-overflow__secondary_nav__handle' ) === false &&
                            lastOfsetTop !== element.offsetTop
                        );
            }, this );



        var secondaryNav = this._template(),
            secondaryUl = secondaryNav.querySelector('ul');
            
            
        

        while( item = items.shift() ) {
            secondaryUl.appendChild( item )
        }
        
        primaryNav.insertBefore( secondaryMenuHandle, primaryNav.lastChild );
        
        //append to handle
        secondaryMenuHandle.appendChild( secondaryNav );
        secondaryMenuHandle.style.visibility = 'visible';





        if ( secondaryUl === undefined ) {
            // no overflow menu, hide the handle
            secondaryMenuHandle.style.visibility = "hidden";
        }

        this.removeAttribute( 'unresolved' );
        this.removeAttribute('refreshing' );

        // watch for changes so we know when to call overflow again
        this._resizeObserver.observe( this, {
            childList: true, 
            characterData: true,
            subtree: true
        } );
    }


    element._makeArray = function( a ) {

        return Array.prototype.slice.call( a, 0 );
        
    }


    element._template = function(){
        
        //look for template override in this element
        var template = this.querySelector('.jb-nav-overflow__secondary_nav__template');

        if ( !template ) {
            template = _currentScript.ownerDocument.querySelector( '#jb-nav-overflow-template' );
        }


        return _currentScript.ownerDocument.importNode( template.content, true );
    }



    // Registers custom element
    document.registerElement('jb-nav-overflow', {
        prototype: element
    });
}());
</script>
